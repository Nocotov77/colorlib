# colorlib

## Описание программы

`colorlib` — это простая библиотека на C++, предназначенная для работы с цветами в форматах RGB, RGBA и HEX. Она предоставляет класс `Color`, который позволяет создавать объекты цвета, манипулировать их каналами (красный, зелёный, синий и альфа), получать строковые представления в различных форматах, а также выполнять смешивание цветов. Программа включает демонстрационное приложение, которое показывает возможности библиотеки, включая создание цветов различными способами, изменение их свойств и вывод в консоль.

Библиотека подходит для учебных целей, экспериментов с цветами или интеграции в проекты, где требуется обработка цветовых данных. Она поддерживает локализацию (например, для вывода текста на русском языке) и предоставляет удобный интерфейс для работы с цветами через конструкторы, геттеры, сеттеры и операторы.

## Требования

Для сборки и работы программы необходимы:

- **Компилятор C++**: Поддерживающий стандарт C++11 или выше (например, `g++`, `clang++`, или MSVC).
- **Операционная система**: Программа протестирована на Linux, macOS и Windows.
- **Библиотеки**: Стандартная библиотека C++ (`<iostream>`, `<string>`, `<tuple>`, `<sstream>`, `<iomanip>`, `<algorithm>`).
- **Локализация**: Для корректного вывода текста на русском языке требуется поддержка локали `Russian` в системе.
- **Система сборки** (опционально): `CMake` или любая другая для упрощения компиляции.

## Установка

1. **Склонируйте или скачайте исходный код**:
   - Если код находится в репозитории, используйте:
     ```bash
     git clone https://github.com/Nocotov77/currconv.git
     cd colorlib
     ```
   - Или скопируйте файлы `main.cpp`, `color.h`, и `color.cpp` в вашу рабочую директорию.

2. **Компиляция**:
   - Для компиляции с помощью `g++` выполните:
     ```bash
     g++ -o colorlib main.cpp color.cpp -std=c++11
     ```
   - Если используете CMake, создайте файл `CMakeLists.txt`:
     ```cmake
     cmake_minimum_required(VERSION 3.10)
     project(colorlib)
     set(CMAKE_CXX_STANDARD 11)
     add_executable(colorlib main.cpp color.cpp)
     ```
     Затем выполните:
     ```bash
     mkdir build && cd build
     cmake ..
     make
     ```

3. **Запуск**:
   - После компиляции запустите программу:
     ```bash
     ./colorlib
     ```

## Подробное описание работы программы

### Обзор функциональности

Программа `colorlib` состоит из трех основных файлов:

- **`color.h`**: Заголовочный файл, содержащий определение класса `Color` с объявлениями методов и операторов.
- **`color.cpp`**: Реализация методов класса `Color`.
- **`main.cpp`**: Демонстрационное приложение, показывающее использование библиотеки.

Класс `Color` предоставляет следующие возможности:

1. **Создание объектов цвета**:
   - Через конструктор с тремя параметрами (RGB): задаёт значения красного, зелёного и синего каналов, альфа-канал по умолчанию равен 255 (полная непрозрачность).
   - Через конструктор с четырьмя параметрами (RGBA): дополнительно задаёт альфа-канал.
   - Через строковое название цвета (например, `"red"`, `"blue"`), с преобразованием в соответствующие RGB-значения.

2. **Получение и изменение значений каналов**:
   - Геттеры (`getRed`, `getGreen`, `getBlue`, `getAlpha`) возвращают значения каналов.
   - Сеттеры (`setRed`, `setGreen`, `setBlue`, `setAlpha`) позволяют изменять значения каналов.
   - Методы `getRGB` и `getRGBA` возвращают кортежи (`std::tuple`) с значениями каналов.

3. **Строковое представление**:
   - Метод `toRGBString`: возвращает строку в формате `RGB(r, g, b)`.
   - Метод `toRGBAString`: возвращает строку в формате `RGBA(r, g, b, a)`.
   - Метод `toHEXString`: возвращает строку в формате HEX (например, `#FF0000` для красного).

4. **Смешивание цветов**:
   - Оператор `/` выполняет смешивание двух цветов, вычисляя среднее арифметическое для каждого канала.

5. **Вывод в поток**:
   - Перегруженный оператор `<<` выводит цвет в формате, включающем RGB, RGBA и HEX представления.

### Пример кода и пояснения

Программа в `main.cpp` демонстрирует все ключевые возможности библиотеки. Рассмотрим основные фрагменты кода:

#### 1. Установка локали
```cpp
setlocale(LC_ALL, "Russian");
```
Эта строка обеспечивает корректный вывод текста на русском языке в консоли, что важно для сообщений, таких как "Красный цвет" или "Полупрозрачный зелёный цвет". Без этого на некоторых системах могут отображаться некорректные символы.

#### 2. Создание объектов цвета
```cpp
Color redColor(255, 0, 0);
Color semiTransparentGreen(0, 255, 0, 128);
Color blueColor("blue");
```
Здесь демонстрируются три способа создания объектов `Color`:
- `redColor` использует конструктор RGB, задавая красный канал на максимум (255), а зелёный и синий — на 0. Альфа-канал автоматически устанавливается в 255.
- `semiTransparentGreen` задаёт полупрозрачный зелёный цвет с альфа-каналом 128 (половина прозрачности).
- `blueColor` создаётся по строке `"blue"`, которая преобразуется в RGB(0, 0, 255) с помощью конструктора в `color.cpp`.

Реализация строкового конструктора:
```cpp
Color::Color(const string& name) {
    string lname = name;
    transform(lname.begin(), lname.end(), lname.begin(), ::tolower);
    if (lname == "black") { red = 0; green = 0; blue = 0; }
    else if (lname == "red") { red = 255; green = 0; blue = 0; }
    // ... другие цвета
    else { red = 0; green = 0; blue = 0; }
    alpha = 255;
}
```
Этот конструктор преобразует входную строку в нижний регистр и сопоставляет её с предопределёнными цветами. Если цвет не найден, устанавливается чёрный цвет (RGB(0, 0, 0)).

#### 3. Вывод цветов
```cpp
cout << "Красный цвет:" << endl;
cout << redColor << endl << endl;
```
Оператор `<<` использует метод `operator<<`, который выводит цвет в трёх форматах:
```cpp
ostream& operator<<(ostream& os, const Color& color) {
    os << color.toRGBString() << ", "
       << color.toRGBAString() << ", "
       << "HEX(" << color.toHEXString() << ")";
    return os;
}
```
Например, для `redColor` вывод будет:
```
RGB(255, 0, 0), RGBA(255, 0, 0, 255), HEX(#FF0000)
```

#### 4. Смешивание цветов
```cpp
Color mixedColor = redColor / blueColor;
```
Оператор `/` создаёт новый объект `Color`, вычисляя среднее значение каналов двух цветов:
```cpp
Color Color::operator/(const Color& other) const {
    int mixedRed = (red + other.red) / 2;
    int mixedGreen = (green + other.green) / 2;
    int mixedBlue = (blue + other.blue) / 2;
    int mixedAlpha = (alpha + other.alpha) / 2;
    return Color(mixedRed, mixedGreen, mixedBlue, mixedAlpha);
}
```
Для красного (RGB(255, 0, 0)) и синего (RGB(0, 0, 255)) результатом будет цвет с каналами:
- Red: (255 + 0) / 2 = 127
- Green: (0 + 0) / 2 = 0
- Blue: (0 + 255) / 2 = 127
- Alpha: (255 + 255) / 2 = 255
Итог: RGB(127, 0, 127), что соответствует пурпурному оттенку.

#### 5. Изменение альфа-канала
```cpp
mixedColor.setAlpha(200);
```
Метод `setAlpha` изменяет значение альфа-канала:
```cpp
void Color::setAlpha(int a) { alpha = a; }
```
После этого цвет `mixedColor` становится полупрозрачным с альфа-каналом 200.

#### 6. Получение значений каналов
```cpp
int r = mixedColor.getRed();
int g = mixedColor.getGreen();
int b = mixedColor.getBlue();
int a = mixedColor.getAlpha();
cout << "Значения каналов смешанного цвета: R=" << r << ", G=" << g
     << ", B=" << b << ", A=" << a << endl;
```
Геттеры возвращают значения каналов напрямую. Также используются кортежи:
```cpp
auto rgb = mixedColor.getRGB();
auto rgba = mixedColor.getRGBA();
cout << "Кортеж RGB: (" << get<0>(rgb) << ", " << get<1>(rgb) << ", " << get<2>(rgb) << ")" << endl;
cout << "Кортеж RGBA: (" << get<0>(rgba) << ", " << get<1>(rgba) << ", "
     << get<2>(rgba) << ", " << get<3>(rgba) << ")" << endl;
```
Методы `getRGB` и `getRGBA` возвращают `std::tuple`, что удобно для работы с несколькими значениями одновременно.

### Ограничения и возможные улучшения

1. **Валидация входных данных**:
   - Текущая реализация не проверяет, находятся ли значения каналов в допустимом диапазоне (0–255). Это может привести к некорректным цветам, если передать, например, отрицательное значение или число больше 255.
   - Рекомендуется добавить проверку в конструкторы и сеттеры, например:
     ```cpp
     void Color::setRed(int r) { red = max(0, min(255, r)); }
     ```

2. **Расширение списка цветов**:
   - Конструктор по строке поддерживает ограниченный набор цветов. Можно использовать `std::unordered_map` для хранения соответствий строк и RGB-значений, что упростит добавление новых цветов.

3. **Поддержка других форматов**:
   - Можно добавить поддержку других цветовых моделей, таких как HSV или CMYK, или парсинг HEX-строк (например, `#FF0000`).

4. **Оптимизация**:
   - Метод `toHEXString` использует `ostringstream`, что может быть заменено на более эффективное форматирование для повышения производительности в крупных приложениях.

### Пример вывода программы

При запуске программы вы получите следующий вывод:
```
Красный цвет:
RGB(255, 0, 0), RGBA(255, 0, 0, 255), HEX(#FF0000)

Полупрозрачный зелёный цвет:
RGB(0, 255, 0), RGBA(0, 255, 0, 128), HEX(#00FF0080)

Синий цвет:
RGB(0, 0, 255), RGBA(0, 0, 255, 255), HEX(#0000FF)

Смешение красного и синего цветов (с использованием оператора "/"):
RGB(127, 0, 127), RGBA(127, 0, 127, 255), HEX(#7F007F)

После установки alpha равным 200 для смешанного цвета:
RGB(127, 0, 127), RGBA(127, 0, 127, 200), HEX(#7F007FC8)

Значения каналов смешанного цвета: R=127, G=0, B=127, A=200
Кортеж RGB: (127, 0, 127)
Кортеж RGBA: (127, 0, 127, 200)
```

## Заключение

`colorlib` — это компактная и функциональная библиотека для работы с цветами в C++. Она демонстрирует объектно-ориентированное программирование, перегрузку операторов и работу со стандартной библиотекой C++. Программа может быть легко расширена для поддержки дополнительных функций, таких как валидация, новые цветовые модели или интеграция с графическими библиотеками (например, SDL или OpenGL).